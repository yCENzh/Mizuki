---
import I18nKey from "../i18n/i18nKey";
import { i18n } from "../i18n/translation";

export interface Props {
	encryptedContent: string;
}

const { encryptedContent } = Astro.props;
---

<div id="password-protection" class="password-protection">
	<div class="password-container">
		<div class="lock-icon">
			<svg
				width="48"
				height="48"
				viewBox="0 0 24 24"
				fill="none"
				xmlns="http://www.w3.org/2000/svg"
			>
				<path
					d="M18 8h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2zM9 6c0-1.66 1.34-3 3-3s3 1.34 3 3v2H9V6z"
					fill="currentColor"></path>
			</svg>
		</div>
		<h2>{i18n(I18nKey.passwordProtectedTitle)}</h2>
		<p>{i18n(I18nKey.passwordProtectedDescription)}</p>
		<div class="password-input-group">
			<input
				type="password"
				id="password-input"
				placeholder={i18n(I18nKey.passwordPlaceholder)}
				class="password-input"
			/>
			<button id="unlock-btn" class="unlock-button"
				>{i18n(I18nKey.passwordUnlock)}</button
			>
		</div>
		<div id="error-message" class="error-message" style="display: none;">
			{i18n(I18nKey.passwordIncorrect)}
		</div>
	</div>
</div>

<div id="decrypted-content" class="decrypted-content" style="display: none;">
</div>

<style>
	.password-protection {
		display: flex;
		justify-content: center;
		align-items: center;
		min-height: 60vh;
		padding: 2rem;
	}

	.password-container {
		text-align: center;
		max-width: 400px;
		width: 100%;
		padding: 2rem;
		border-radius: 12px;
		background: transparent;
		border: 1px solid var(--line-divider);
		box-shadow: none;
	}

	.lock-icon {
		display: flex;
		justify-content: center;
		margin-bottom: 1rem;
		color: var(--primary);
	}

	.password-container h2 {
		margin-bottom: 0.5rem;
		color: rgba(0, 0, 0, 0.85);
		font-size: 1.5rem;
	}

	:global(.dark) .password-container h2 {
		color: rgba(255, 255, 255, 0.85);
	}

	.password-container p {
		margin-bottom: 1.5rem;
		color: rgba(0, 0, 0, 0.75);
		opacity: 0.8;
	}

	:global(.dark) .password-container p {
		color: rgba(255, 255, 255, 0.75);
	}

	.password-input-group {
		display: flex;
		gap: 0.5rem;
		margin-bottom: 1rem;
		align-items: stretch;
	}

	.password-input {
		flex: 1;
		min-width: 0; /* å…è®¸è¾“å…¥æ¡†åœ¨éœ€è¦æ—¶ç¼©å° */
		padding: 0.75rem 1rem;
		border: 1px solid var(--line-divider);
		border-radius: 8px;
		background: transparent;
		color: rgba(0, 0, 0, 0.85);
		font-size: 1rem;
		transition: border-color 0.2s ease;
	}

	:global(.dark) .password-input {
		color: rgba(255, 255, 255, 0.85);
	}

	.password-input::placeholder {
		color: rgba(0, 0, 0, 0.5);
	}

	:global(.dark) .password-input::placeholder {
		color: rgba(255, 255, 255, 0.5);
	}

	.password-input:focus {
		outline: none;
		border-color: var(--primary);
	}

	.unlock-button {
		padding: 0.75rem 1.5rem;
		background: transparent;
		color: var(--primary);
		border: 1px solid var(--primary);
		border-radius: 8px;
		font-size: 1rem;
		cursor: pointer;
		transition:
			border-color 0.2s,
			color 0.2s,
			background 0.2s;
		white-space: nowrap;
		flex-shrink: 0;
		min-width: fit-content;
		max-width: max-content;
	}

	.unlock-button:hover {
		background: var(--primary);
		color: white;
		border-color: var(--primary);
	}

	.unlock-button:disabled {
		opacity: 0.6;
		cursor: not-allowed;
	}

	.error-message {
		color: #ef4444;
		font-size: 0.875rem;
		margin-top: 0.5rem;
	}

	.decrypted-content {
		animation: fadeIn 0.3s ease-in-out;
	}

	@keyframes fadeIn {
		from {
			opacity: 0;
			transform: translateY(10px);
		}
		to {
			opacity: 1;
			transform: translateY(0);
		}
	}

	/* æ¡Œé¢ç«¯ä¼˜åŒ– - ç¡®ä¿æŒ‰é’®å¸ƒå±€æ­£å¸¸ */
	@media (min-width: 769px) {
		.password-input-group {
			flex-wrap: nowrap;
		}

		.unlock-button {
			max-width: 40%;
		}
	}

	/* ç§»åŠ¨ç«¯é€‚é… */
	@media (max-width: 768px) {
		.password-protection {
			padding: 1rem;
			min-height: 50vh;
		}

		.password-container {
			max-width: none;
			width: 100%;
			padding: 1.5rem;
			margin: 0 0.5rem;
		}

		.password-container h2 {
			font-size: 1.25rem;
			margin-bottom: 0.75rem;
		}

		.password-container p {
			font-size: 0.9rem;
			margin-bottom: 1.25rem;
		}

		.password-input-group {
			flex-direction: column;
			gap: 0.75rem;
		}

		.password-input {
			padding: 0.875rem 1rem;
			font-size: 1rem;
			width: 100%;
		}

		.unlock-button {
			padding: 0.875rem 1rem;
			font-size: 1rem;
			max-width: 100%;
			width: 100%;
			white-space: nowrap;
		}

		.error-message {
			font-size: 0.8rem;
			text-align: center;
		}
	}

	/* å°å±æ‰‹æœºé€‚é… */
	@media (max-width: 480px) {
		.password-protection {
			padding: 0.75rem;
		}

		.password-container {
			padding: 1.25rem;
			margin: 0 0.25rem;
		}

		.password-container h2 {
			font-size: 1.125rem;
		}

		.password-container p {
			font-size: 0.85rem;
		}

		.password-input {
			padding: 0.75rem 0.875rem;
			font-size: 0.95rem;
		}

		.unlock-button {
			padding: 0.75rem 0.875rem;
			font-size: 0.95rem;
		}
	}
</style>

<script
	is:inline
	define:vars={{
		encryptedContent,
		i18nUnlocking: i18n(I18nKey.passwordUnlocking),
		i18nIncorrect: i18n(I18nKey.passwordIncorrect),
		i18nDecryptError: i18n(I18nKey.passwordDecryptError),
		i18nUnlock: i18n(I18nKey.passwordUnlock),
		i18nCopyFailed: i18n(I18nKey.copyFailed),
		i18nPasswordRequired: i18n(I18nKey.passwordRequired),
		i18nDecryptionError: i18n(I18nKey.decryptionError),
		i18nPasswordDecryptRetry: i18n(I18nKey.passwordDecryptRetry),
	}}
>
	// å¯¼å…¥åŠ å¯†åº“ - ä½¿ç”¨æœ¬åœ°æ–‡ä»¶
	async function loadCryptoLibraries() {
		if (typeof CryptoJS === "undefined") {
			await new Promise((resolve, reject) => {
				const script = document.createElement("script");
				script.src = "/assets/js/crypto-js.min.js";
				script.onload = resolve;
				script.onerror = reject;
				document.head.appendChild(script);
			});
		}
	}

	// åŠ è½½è¯­æ³•é«˜äº®åº“
	async function loadSyntaxHighlighter() {
		if (typeof hljs === "undefined") {
			await new Promise((resolve, reject) => {
				const script = document.createElement("script");
				script.src = "/assets/js/highlight.min.js";
				script.onload = resolve;
				script.onerror = reject;
				document.head.appendChild(script);
			});
			await new Promise((resolve) => setTimeout(resolve, 100));
		}
	}

	// ä¸ºä»£ç å—æ·»åŠ æ ·å¼å’ŒåŠŸèƒ½çš„å‡½æ•° - ä½¿ç”¨highlight.jsè¿›è¡Œè¯­æ³•é«˜äº®ï¼Œä½†ä½¿ç”¨å…¨å±€expressive-codeæ ·å¼
	async function enhanceCodeBlocks(container) {
		// åŠ è½½è¯­æ³•é«˜äº®åº“
		await loadSyntaxHighlighter();

		const codeBlocks = container.querySelectorAll("pre code");

		codeBlocks.forEach((codeElement) => {
			const preElement = codeElement.parentElement;
			if (!preElement) return;

			// è·å–è¯­è¨€ä¿¡æ¯
			const className = codeElement.className || "";
			const langMatch = className.match(/language-(\w+)/);
			const language = langMatch ? langMatch[1] : "text";

			// è·å–åŸå§‹ä»£ç æ–‡æœ¬
			const codeText = codeElement.textContent || "";

			// ä½¿ç”¨ highlight.js è¿›è¡Œè¯­æ³•é«˜äº®
			let highlightedCode = codeText;
			if (typeof hljs !== "undefined") {
				try {
					if (language && language !== "text") {
						const result = hljs.highlight(codeText, {
							language: language,
						});
						highlightedCode = result.value;
					} else {
						const result = hljs.highlightAuto(codeText);
						highlightedCode = result.value;
					}
				} catch (e) {
					console.warn("Syntax highlight failed:", e);
					highlightedCode = codeText;
				}
			}

			// åˆ›å»ºexpressive-codeæ ·å¼çš„åŒ…è£…ç»“æ„
			const wrapper = document.createElement("div");
			wrapper.className = "expressive-code";

			const frame = document.createElement("div");
			frame.className = "frame";

			// åˆ›å»ºæ–°çš„preå…ƒç´ 
			const newPre = document.createElement("pre");
			newPre.className = "astro-code";
			newPre.setAttribute("data-language", language);
			newPre.setAttribute("tabindex", "0");

			// åˆ›å»ºæ–°çš„codeå…ƒç´ 
			const newCode = document.createElement("code");
			newCode.className = `language-${language}`;

			// å°†é«˜äº®åçš„ä»£ç æŒ‰è¡Œåˆ†å‰²å¹¶æ·»åŠ .lineç±»ï¼ˆæ¨¡æ‹Ÿexpressive-codeçš„è¡Œç»“æ„ï¼‰
			const lines = highlightedCode.split("\n");
			lines.forEach((line, index) => {
				const lineSpan = document.createElement("span");
				lineSpan.className = "line";
				lineSpan.innerHTML = line || " "; // ç©ºè¡Œä¹Ÿè¦ä¿ç•™
				newCode.appendChild(lineSpan);

				// é™¤äº†æœ€åä¸€è¡Œï¼Œéƒ½æ·»åŠ æ¢è¡Œç¬¦
				if (index < lines.length - 1) {
					newCode.appendChild(document.createTextNode("\n"));
				}
			});

			newPre.appendChild(newCode);

			// å°† pre ä»åŸä½ç½®ç§»é™¤å¹¶é‡æ–°åŒ…è£…
			const parent = preElement.parentNode;
			parent.insertBefore(wrapper, preElement);
			parent.removeChild(preElement);

			frame.appendChild(newPre);

			// æ·»åŠ å¤åˆ¶æŒ‰é’®
			const copyBtn = document.createElement("button");
			copyBtn.className = "copy-btn";
			copyBtn.setAttribute("aria-label", "Copy code");
			copyBtn.setAttribute("type", "button");

			const copyBtnIcon = document.createElement("div");
			copyBtnIcon.className = "copy-btn-icon";

			// å¤åˆ¶å›¾æ ‡SVG
			const copyIcon = document.createElementNS(
				"http://www.w3.org/2000/svg",
				"svg",
			);
			copyIcon.setAttribute("viewBox", "0 -960 960 960");
			copyIcon.setAttribute("class", "copy-btn-icon copy-icon");
			const copyPath = document.createElementNS(
				"http://www.w3.org/2000/svg",
				"path",
			);
			copyPath.setAttribute(
				"d",
				"M368.37-237.37q-34.48 0-58.74-24.26-24.26-24.26-24.26-58.74v-474.26q0-34.48 24.26-58.74 24.26-24.26 58.74-24.26h378.26q34.48 0 58.74 24.26 24.26 24.26 24.26 58.74v474.26q0 34.48-24.26 58.74-24.26 24.26-58.74 24.26H368.37Zm0-83h378.26v-474.26H368.37v474.26Zm-155 238q-34.48 0-58.74-24.26-24.26-24.26-24.26-58.74v-557.26h83v557.26h461.26v83H213.37Z",
			);
			copyIcon.appendChild(copyPath);

			// æˆåŠŸå›¾æ ‡SVG
			const successIcon = document.createElementNS(
				"http://www.w3.org/2000/svg",
				"svg",
			);
			successIcon.setAttribute("viewBox", "0 -960 960 960");
			successIcon.setAttribute("class", "copy-btn-icon success-icon");
			const successPath = document.createElementNS(
				"http://www.w3.org/2000/svg",
				"path",
			);
			successPath.setAttribute(
				"d",
				"m389-377.13 294.7-294.7q12.58-12.67 29.52-12.67 16.93 0 29.61 12.67 12.67 12.68 12.67 29.53 0 16.86-12.28 29.14L419.07-288.41q-12.59 12.67-29.52 12.67-16.94 0-29.62-12.67L217.41-430.93q-12.67-12.68-12.79-29.45-.12-16.77 12.55-29.45 12.68-12.67 29.62-12.67 16.93 0 29.28 12.67L389-377.13Z",
			);
			successIcon.appendChild(successPath);

			copyBtnIcon.appendChild(copyIcon);
			copyBtnIcon.appendChild(successIcon);
			copyBtn.appendChild(copyBtnIcon);

			// å¤åˆ¶åŠŸèƒ½ - ä½¿ç”¨ä¸å…¨å±€ä¸€è‡´çš„é€»è¾‘
			copyBtn.addEventListener("click", async () => {
				try {
					// è·å–æ‰€æœ‰.lineå…ƒç´ çš„æ–‡æœ¬å†…å®¹ï¼ˆä¸åŒ…æ‹¬è¡Œå·ï¼‰
					const lineElements = newCode.querySelectorAll(".line");
					const code = Array.from(lineElements)
						.map((el) => el.textContent)
						.join("\n");

					await navigator.clipboard.writeText(code);
					copyBtn.classList.add("success");

					const timeoutId = copyBtn.getAttribute("data-timeout-id");
					if (timeoutId) {
						clearTimeout(parseInt(timeoutId));
					}

					const newTimeoutId = setTimeout(() => {
						copyBtn.classList.remove("success");
					}, 1000);

					copyBtn.setAttribute(
						"data-timeout-id",
						newTimeoutId.toString(),
					);
				} catch (err) {
					console.error(i18nCopyFailed, err);
				}
			});

			frame.appendChild(copyBtn);
			wrapper.appendChild(frame);
		});
	}

	// ä¸ºæ ‡é¢˜æ·»åŠ idå’Œé”šç‚¹é“¾æ¥çš„å‡½æ•°
	function addHeadingAnchors(container) {
		const headings = container.querySelectorAll("h1, h2, h3, h4, h5, h6");
		const usedIds = new Set();

		headings.forEach((heading) => {
			// ç”Ÿæˆslug idï¼ˆæ¨¡æ‹Ÿrehype-slugåŠŸèƒ½ï¼‰
			let slug = heading.textContent
				.toLowerCase()
				.trim()
				.replace(/[^\w\s-]/g, "") // ç§»é™¤ç‰¹æ®Šå­—ç¬¦
				.replace(/[\s_-]+/g, "-") // æ›¿æ¢ç©ºæ ¼å’Œä¸‹åˆ’çº¿ä¸ºè¿å­—ç¬¦
				.replace(/^-+|-+$/g, ""); // ç§»é™¤å¼€å¤´å’Œç»“å°¾çš„è¿å­—ç¬¦

			// ç¡®ä¿idå”¯ä¸€
			let uniqueSlug = slug;
			let counter = 1;
			while (usedIds.has(uniqueSlug)) {
				uniqueSlug = `${slug}-${counter}`;
				counter++;
			}
			usedIds.add(uniqueSlug);

			// è®¾ç½®id
			heading.id = uniqueSlug;

			// æ·»åŠ é”šç‚¹é“¾æ¥ï¼ˆæ¨¡æ‹Ÿrehype-autolink-headingsåŠŸèƒ½ï¼‰
			const anchor = document.createElement("span");
			anchor.className = "anchor-icon";
			anchor.setAttribute("data-pagefind-ignore", "true");
			anchor.textContent = "#";

			const anchorWrapper = document.createElement("a");
			anchorWrapper.className = "anchor";
			anchorWrapper.href = `#${uniqueSlug}`;
			anchorWrapper.appendChild(anchor);

			// å°†é”šç‚¹æ·»åŠ åˆ°æ ‡é¢˜æœ«å°¾
			heading.appendChild(anchorWrapper);
		});
	}

	async function renderMarkdownContent(markdownText) {
		// åŠ è½½markedåº“ç”¨äºmarkdownæ¸²æŸ“ - ä½¿ç”¨æœ¬åœ°æ–‡ä»¶
		if (typeof marked === "undefined") {
			await new Promise((resolve, reject) => {
				const script = document.createElement("script");
				script.src = "/assets/js/marked.min.js";
				script.onload = resolve;
				script.onerror = reject;
				document.head.appendChild(script);
			});
		}

		// é…ç½®markedçš„åŸºæœ¬é€‰é¡¹
		marked.setOptions({
			breaks: true,
			gfm: true,
		});

		markdownText = markdownText.replace(
            /^:::(note|tip|important|warning|caution)(?:\[(.*?)\])?\s*\n([\s\S]*?)\n:::/gm,
            (_, type, title, content) => {
                const displayTitle = title ? title : type.toUpperCase();
                return `<blockquote class="admonition bdm-${type}"><span class="bdm-title">${displayTitle}</span>\n\n${content}\n\n</blockquote>`;
            }
        );

		markdownText = markdownText.replace(
			/::github\{repo="([^"]+)"\}/g,
			(_, repo) => {
				return `<div class="github-card-container"><a href="https://github.com/${repo}" target="_blank" class="github-card-link">ğŸ“¦ ${repo} (Click to view on GitHub)</a></div>`;
			},
		);

		markdownText = markdownText.replace(
			/:spoiler\[(.*?)\]/g,
			(_, content) => {
				return `<span class="spoiler" title="Spoiler">${content}</span>`;
			},
		);

		const contentDiv = document.getElementById("decrypted-content");
		const htmlContent = marked.parse(markdownText);

		// åˆ›å»ºä¸æ­£å¸¸æ–‡ç« å®Œå…¨ç›¸åŒçš„ç»“æ„
		const markdownWrapper = document.createElement("div");
		markdownWrapper.className =
			"prose dark:prose-invert prose-base !max-w-none custom-md mb-6 markdown-content onload-animation";
		markdownWrapper.setAttribute("data-pagefind-body", "");
		markdownWrapper.innerHTML = htmlContent;

		// ä¸ºæ ‡é¢˜æ·»åŠ idå’Œé”šç‚¹é“¾æ¥ï¼ˆæ¨¡æ‹Ÿrehype-slugå’Œrehype-autolink-headingsæ’ä»¶åŠŸèƒ½ï¼‰
		addHeadingAnchors(markdownWrapper);

		// ä¸ºä»£ç å—æ·»åŠ æ ·å¼å’ŒåŠŸèƒ½ï¼ˆå¼‚æ­¥ï¼Œä½¿ç”¨ä¸å…¨å±€ä¸€è‡´çš„æ ·å¼ï¼‰
		await enhanceCodeBlocks(markdownWrapper);

		// æ¸…ç©ºå®¹å™¨å¹¶æ·»åŠ æ–°å†…å®¹
		contentDiv.innerHTML = "";
		contentDiv.appendChild(markdownWrapper);

		// é‡ç½®contentDivçš„æ ·å¼ï¼Œè®©å®ƒä½œä¸ºæ™®é€šå®¹å™¨
		contentDiv.className = "";
		contentDiv.style.cssText = "";

		// è§¦å‘TOCæ›´æ–°
		const tocElement = document.querySelector("table-of-contents");
		if (tocElement && typeof tocElement.regenerateTOC === "function") {
			// ç­‰å¾…DOMæ›´æ–°åé‡æ–°ç”ŸæˆTOC
			setTimeout(() => {
				tocElement.regenerateTOC();
				tocElement.init();
			}, 100);
		}

		// è§¦å‘ç§»åŠ¨ç«¯TOCæ›´æ–°
		if (typeof window.mobileTOCInit === "function") {
			setTimeout(() => {
				window.mobileTOCInit();
			}, 150);
		}

		// è§¦å‘åŠ¨ç”»ç»“æŸäº‹ä»¶ï¼Œè®©TOCçŸ¥é“åŠ¨ç”»å®Œæˆ
		const animationEndEvent = new Event("animationend");
		markdownWrapper.dispatchEvent(animationEndEvent);
	}

	async function initPasswordProtection() {
		// å¦‚æœæœ‰ä¿å­˜çš„å¯†ç ï¼Œç«‹å³éšè—è¾“å…¥æ¡†ï¼Œé¿å…é—ªçƒ
		const savedPassword = sessionStorage.getItem(
			"page-password-" + window.location.pathname,
		);
		const protectionDiv = document.getElementById("password-protection");
		if (savedPassword && protectionDiv) {
			const inputGroup = protectionDiv.querySelector(
				".password-input-group",
			);
			if (inputGroup) {
        inputGroup.style.visibility = 'hidden';
      }
			const hint = protectionDiv.querySelector(".password-container p");
			if (hint) {
				hint.setAttribute("data-original-text", hint.textContent);
				hint.textContent = i18nUnlocking;
			}
			protectionDiv.classList.add("auto-unlocking");
		}

		await loadCryptoLibraries();

		const passwordInput = document.getElementById("password-input");
		const unlockBtn = document.getElementById("unlock-btn");
		const errorMessage = document.getElementById("error-message");
		const contentDiv = document.getElementById("decrypted-content");

		async function attemptUnlock() {
			const inputPassword = passwordInput.value.trim() || savedPassword;

			if (!inputPassword) {
				showError(i18nPasswordRequired);
				return;
			}

			unlockBtn.disabled = true;
			unlockBtn.textContent = i18nUnlocking;
			errorMessage.style.display = "none";

			try {
				// ç›´æ¥å°è¯•ä½¿ç”¨è¾“å…¥çš„å¯†ç è§£å¯†
				const decryptedBytes = CryptoJS.AES.decrypt(
					encryptedContent,
					inputPassword,
				);
				const decryptedString = decryptedBytes.toString(
					CryptoJS.enc.Utf8,
				);

				// éªŒè¯è§£å¯†ç»“æœ (æ£€æŸ¥ Magic String å‰ç¼€)
				if (
					!decryptedString ||
					!decryptedString.startsWith("MIZUKI-VERIFY:")
				) {
					// è§£å¯†å¤±è´¥æˆ–å¯†ç é”™è¯¯
					showError(i18nIncorrect);

					// å¦‚æœæ˜¯è‡ªåŠ¨è§£é”å¤±è´¥ï¼Œæ¸…é™¤é”™è¯¯çš„ç¼“å­˜
					if (savedPassword) {
						sessionStorage.removeItem(
							"page-password-" + window.location.pathname,
						);
						// æ¢å¤ç•Œé¢
						const inputGroup = protectionDiv.querySelector(
							".password-input-group",
						);
						if (inputGroup) {
              inputGroup.style.visibility = 'visible';
            }
						const hint = protectionDiv.querySelector(
							".password-container p",
						);
						if (hint && hint.hasAttribute("data-original-text")) {
							hint.textContent =
								hint.getAttribute("data-original-text");
						}
						passwordInput.value = "";
						protectionDiv.classList.remove("auto-unlocking");
					}
					return;
				}

				// ç§»é™¤å‰ç¼€ï¼Œè·å–çœŸå®å†…å®¹
				const realContent = decryptedString.replace(
					"MIZUKI-VERIFY:",
					"",
				);

				// æ¸²æŸ“ Markdown
				await renderMarkdownContent(realContent);

				protectionDiv.style.display = "none";
				contentDiv.style.display = "block";

				// è§£é”æˆåŠŸï¼Œä¿å­˜æ­£ç¡®å¯†ç 
				sessionStorage.setItem(
					"page-password-" + window.location.pathname,
					inputPassword,
				);
			} catch (error) {
				console.error(i18nDecryptionError, error);
				showError(i18nPasswordDecryptRetry);
			} finally {
				unlockBtn.disabled = false;
				unlockBtn.textContent = i18nUnlock;
			}
		}

		function showError(message) {
			errorMessage.textContent = message;
			errorMessage.style.display = "block";
			// å¦‚æœä¸æ˜¯è‡ªåŠ¨è§£é”æ¨¡å¼ï¼Œæ‰èšç„¦
			if (!protectionDiv.classList.contains("auto-unlocking")) {
				passwordInput.focus();
			}
		}

		// äº‹ä»¶ç›‘å¬
		unlockBtn.addEventListener("click", () => attemptUnlock());
		passwordInput.addEventListener("keypress", (e) => {
			if (e.key === "Enter") attemptUnlock();
		});

		// å¦‚æœæœ‰ä¿å­˜çš„å¯†ç ï¼Œè‡ªåŠ¨è§¦å‘è§£é”
		if (savedPassword) {
			attemptUnlock();
		} else {
			passwordInput.focus();
		}
	}

	// é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
	if (document.readyState === "loading") {
		document.addEventListener("DOMContentLoaded", initPasswordProtection);
	} else {
		initPasswordProtection();
	}
</script>
