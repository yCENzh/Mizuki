---
import ImageWrapper from "../components/misc/ImageWrapper.astro";
import { sidebarLayoutConfig, siteConfig } from "../config";
import localAnimeList from "../data/anime";
import I18nKey from "../i18n/i18nKey";
import { i18n } from "../i18n/translation";
import MainGridLayout from "../layouts/MainGridLayout.astro";
import fs from "node:fs";
import path from "node:path";

interface AnimeItem {
	title: string;
	cover: string;
	link: string;
	status: string;
	rating: number;
	progress: number;
	totalEpisodes: number;
	description: string;
	year: string;
	studio: string;
	genre: string[];
}

if (!siteConfig.featurePages.anime) {
	return Astro.redirect("/404/");
}

const isBothSidebarMode = sidebarLayoutConfig.position === "both";
const BANGUMI_USER_ID = siteConfig.bangumi?.userId || "your-user-id";
const ANIME_MODE = siteConfig.anime?.mode || "bangumi";

let animeList: AnimeItem[] = [];

if (ANIME_MODE === "local") {
	animeList = localAnimeList;
} else {
	const isDev = import.meta.env.DEV;
	const shouldFetchOnDev = siteConfig.bangumi?.fetchOnDev ?? false;
	const skipLoad = isDev && !shouldFetchOnDev;

	if (skipLoad) {
		console.log("[Dev] Skipping Bangumi data load (fetchOnDev is off).");
		animeList = [];
	} else {
		try {
			const dataPath = path.join(
				process.cwd(),
				"src/data/bangumi-data.json",
			);
			if (fs.existsSync(dataPath)) {
				const fileContent = fs.readFileSync(dataPath, "utf-8");
				const rawData = JSON.parse(fileContent);
				animeList = rawData.map((item: any) => ({
					title: item.title || "Unknown",
					cover: item.cover || "",
					link: item.link || "",
					status: item.status || "planned",
					rating: Number(item.rating) || 0,
					progress: Number(item.progress) || 0,
					totalEpisodes: Number(item.totalEpisodes) || 12,
					description: item.description || "",
					year: item.year || "",
					studio: item.studio || "",
					genre: Array.isArray(item.genre) ? item.genre : [],
				}));
			} else {
				console.warn(`Bangumi data file not found at ${dataPath}.`);
				animeList = [];
			}
		} catch (error) {
			console.error("Failed to load anime data:", error);
			animeList = [];
		}
	}
}

function getStatusInfo(status: string) {
	switch (status) {
		case "watching":
			return {
				text: i18n(I18nKey.animeStatusWatching),
				class: "bg-green-100 text-green-700 dark:bg-green-900/30 dark:text-green-300",
				icon: "‚ñ∂",
			};
		case "completed":
			return {
				text: i18n(I18nKey.animeStatusCompleted),
				class: "bg-blue-100 text-blue-700 dark:bg-blue-900/30 dark:text-blue-300",
				icon: "‚úì",
			};
		case "planned":
			return {
				text: i18n(I18nKey.animeStatusPlanned),
				class: "bg-amber-100 text-amber-700 dark:bg-amber-900/30 dark:text-amber-300",
				icon: "‚è∞",
			};
		case "onhold":
			return {
				text: i18n(I18nKey.animeStatusOnHold),
				class: "bg-purple-100 text-purple-700 dark:bg-purple-900/30 dark:text-purple-300",
				icon: "‚è∏",
			};
		case "dropped":
			return {
				text: i18n(I18nKey.animeStatusDropped),
				class: "bg-red-100 text-red-700 dark:bg-red-900/30 dark:text-red-300",
				icon: "‚úó",
			};
		default:
			return {
				text: status,
				class: "bg-gray-100 text-gray-700 dark:bg-gray-800 dark:text-gray-300",
				icon: "?",
			};
	}
}

const INITIAL_DISPLAY_COUNT = 24;
---

<MainGridLayout
	title={i18n(I18nKey.anime)}
	description={i18n(I18nKey.animeSubtitle)}
>
	<div
		class="flex w-full rounded-[var(--radius-large)] overflow-hidden relative min-h-32"
	>
		<div class="card-base z-10 px-9 py-6 relative w-full">
			<div class="relative w-full mb-8">
				<div class="mb-6">
					<h1
						class="text-4xl font-bold text-black/90 dark:text-white/90 mb-2 relative
                    before:w-1 before:h-8 before:rounded-md before:bg-[var(--primary)]
                    before:absolute before:top-1/2 before:-translate-y-1/2 before:-left-4"
					>
						{i18n(I18nKey.animeTitle)}
					</h1>
					<p class="text-black/75 dark:text-white/75">
						{i18n(I18nKey.animeSubtitle)}
					</p>
				</div>

				<div class="mb-6">
					<div class="filter-container flex flex-wrap gap-2">
						<button class="filter-tag active" data-status="all"
							>{i18n(I18nKey.animeFilterAll)}</button
						>
						<button class="filter-tag" data-status="watching"
							>{i18n(I18nKey.animeStatusWatching)}</button
						>
						<button class="filter-tag" data-status="planned"
							>{i18n(I18nKey.animeStatusPlanned)}</button
						>
						<button class="filter-tag" data-status="completed"
							>{i18n(I18nKey.animeStatusCompleted)}</button
						>
						{
							ANIME_MODE === "bangumi" && (
								<>
									<button
										class="filter-tag"
										data-status="onhold"
									>
										{i18n(I18nKey.animeStatusOnHold)}
									</button>
									<button
										class="filter-tag"
										data-status="dropped"
									>
										{i18n(I18nKey.animeStatusDropped)}
									</button>
								</>
							)
						}
					</div>
				</div>
			</div>

			<div class="mb-8">
				{
					ANIME_MODE !== "local" &&
					BANGUMI_USER_ID === "your-user-id" ? (
						<div class="text-center py-12">
							<div class="text-5xl mb-4">üò¢</div>
							<h3 class="text-xl font-medium text-black/80 dark:text-white/80 mb-2">
								{i18n(I18nKey.animeEmpty)}
							</h3>
							<p class="text-black/60 dark:text-white/60">
								ËØ∑Âú® src/config.ts Êñá‰ª∂‰∏≠ËÆæÁΩÆ‰Ω†ÁöÑ Bangumi Áî®Êà∑ID
							</p>
						</div>
					) : animeList.length > 0 ? (
						<>
							<div
								id="anime-list-container"
								class={`anime-grid-container grid gap-4 md:gap-6 list-mode ${
									isBothSidebarMode
										? "both-sidebar"
										: "single-sidebar"
								}`}
							>
								{animeList.map((anime, index) => {
									const statusInfo = getStatusInfo(
										anime.status,
									);
									const progressPercent =
										anime.totalEpisodes > 0
											? (anime.progress /
													anime.totalEpisodes) *
												100
											: 0;
									const isHidden =
										index >= INITIAL_DISPLAY_COUNT;

									return (
										<div
											class={`group relative bg-[var(--card-bg)] border border-[var(--line-divider)] rounded-[var(--radius-large)] overflow-hidden transition-all duration-300 hover:shadow-lg hover:scale-[1.02] ${isHidden ? "hidden initial-hidden" : ""}`}
											data-anime-status={anime.status}
										>
											<div class="relative aspect-[2/3] overflow-hidden">
												<a
													href={anime.link}
													target="_blank"
													rel="noopener noreferrer"
													class="block w-full h-full"
												>
													<ImageWrapper
														src={anime.cover}
														alt={anime.title}
														class="w-full h-full object-cover transition-transform duration-300 group-hover:scale-110"
													/>
													<div class="absolute inset-0 bg-gradient-to-t from-black/60 via-transparent to-transparent opacity-0 group-hover:opacity-100 transition-opacity duration-300">
														<div class="absolute inset-0 flex items-center justify-center">
															<div class="w-12 h-12 rounded-full bg-white/90 flex items-center justify-center">
																<svg
																	class="w-6 h-6 text-gray-800 ml-1"
																	fill="currentColor"
																	viewBox="0 0 24 24"
																>
																	<path d="M8 5v14l11-7z" />
																</svg>
															</div>
														</div>
													</div>
												</a>

												<div
													class={`absolute top-2 left-2 px-2 py-1 rounded-md text-xs font-medium ${statusInfo.class}`}
												>
													<span class="mr-1">
														{statusInfo.icon}
													</span>
													<span>
														{statusInfo.text}
													</span>
												</div>

												<div class="absolute top-2 right-2 bg-black/70 text-white px-2 py-1 rounded-md text-xs font-medium flex items-center gap-1">
													<svg
														class="w-3 h-3 text-yellow-400"
														fill="currentColor"
														viewBox="0 0 20 20"
													>
														<path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z" />
													</svg>
													<span>{anime.rating}</span>
												</div>

												{anime.status ===
													"watching" && (
													<div class="absolute bottom-0 left-0 right-0 bg-gradient-to-t from-black/80 to-transparent p-2">
														<div class="w-full bg-white/20 rounded-full h-1.5 mb-1">
															<div
																class="bg-gradient-to-r from-emerald-400 to-teal-400 h-1.5 rounded-full transition-all duration-300"
																style={`width: ${progressPercent}%`}
															/>
														</div>
														<div class="text-white text-xs font-medium">
															{anime.progress}/
															{
																anime.totalEpisodes
															}{" "}
															(
															{Math.round(
																progressPercent,
															)}
															%)
														</div>
													</div>
												)}
											</div>

											<div class="p-3">
												<h3 class="text-sm font-bold text-black/90 dark:text-white/90 mb-1 line-clamp-2 leading-tight">
													{anime.title}
												</h3>
												<p class="text-black/60 dark:text-white/60 text-xs mb-2 line-clamp-2">
													{anime.description}
												</p>

												<div class="space-y-1 text-xs">
													<div class="flex justify-between">
														<span class="text-black/50 dark:text-white/50">
															{i18n(
																I18nKey.animeYear,
															)}
														</span>
														<span class="text-black/70 dark:text-white/70">
															{anime.year}
														</span>
													</div>
													<div class="flex justify-between">
														<span class="text-black/50 dark:text-white/50">
															{i18n(
																I18nKey.animeStudio,
															)}
														</span>
														<span class="text-black/70 dark:text-white/70 truncate ml-2">
															{anime.studio}
														</span>
													</div>
													<div class="flex flex-wrap gap-1 mt-2">
														{anime.genre.map(
															(g) => (
																<span class="px-1.5 py-0.5 bg-[var(--btn-regular-bg)] text-black/70 dark:text-white/70 rounded text-xs">
																	{g}
																</span>
															),
														)}
													</div>
												</div>
											</div>
										</div>
									);
								})}
							</div>

							{animeList.length > INITIAL_DISPLAY_COUNT && (
								<div
									id="infinite-scroll-sentinel"
									class="w-full h-20 flex items-center justify-center mt-8"
								>
									<div class="loading-spinner w-8 h-8 border-4 border-[var(--primary)] border-t-transparent rounded-full animate-spin" />
								</div>
							)}
						</>
					) : (
						<div class="text-center py-12">
							<div class="text-5xl mb-4">üò¢</div>
							<h3 class="text-xl font-medium text-black/80 dark:text-white/80 mb-2">
								{i18n(I18nKey.animeEmpty)}
							</h3>
							<p class="text-black/60 dark:text-white/60">
								{ANIME_MODE === "local"
									? i18n(I18nKey.animeEmptyLocal)
									: i18n(I18nKey.animeEmptyBangumi)}
							</p>
						</div>
					)
				}
			</div>
		</div>
	</div>

	<script is:inline define:vars={{ isBothSidebarMode }}>
		(function () {
			function initAnimeLayout() {
				const animeListContainer = document.getElementById(
					"anime-list-container",
				);
				if (!animeListContainer) return false;
				const currentLayout =
					localStorage.getItem("postListLayout") || "list";
				updateAnimeListLayout(currentLayout);
				return true;
			}

			let retryCount = 0;
			const maxRetries = 10;
			function tryInit() {
				if (initAnimeLayout()) return;
				if (retryCount < maxRetries) {
					retryCount++;
					const delay = Math.min(
						100 * Math.pow(1.5, retryCount),
						1000,
					);
					setTimeout(tryInit, delay);
				} else {
					setTimeout(() => {
						const animeListContainer = document.getElementById(
							"anime-list-container",
						);
						if (animeListContainer) {
							const currentLayout =
								localStorage.getItem("postListLayout") ||
								"list";
							updateAnimeListLayout(currentLayout);
						}
					}, 2000);
				}
			}

			if (document.readyState === "loading") {
				document.addEventListener("DOMContentLoaded", tryInit);
			} else {
				tryInit();
			}

			function updateAnimeListLayout(layout) {
				const animeListContainer = document.getElementById(
					"anime-list-container",
				);
				if (!animeListContainer) return;
				if (animeListContainer.dataset.currentLayout === layout) return;
				animeListContainer.dataset.currentLayout = layout;

				const animeItems = Array.from(
					document.querySelectorAll("[data-anime-status]"),
				);
				const firstPositions = new Map();
				animeItems.forEach((item) => {
					if (item.offsetParent !== null) {
						const rect = item.getBoundingClientRect();
						firstPositions.set(item, {
							left: rect.left,
							top: rect.top,
							width: rect.width,
							height: rect.height,
						});
					}
				});

				// Á¶ÅÁî® Transition ‰ª•‰æøËÆ°ÁÆó
				const style = document.createElement("style");
				style.innerHTML = `.anime-item, .anime-item * { transition: none !important; }`;
				document.head.appendChild(style);

				animeListContainer.classList.remove("list-mode", "grid-mode");
				if (layout === "grid") {
					animeListContainer.classList.add(
						"grid-mode",
						"grid",
						"grid-cols-1",
						"md:grid-cols-2",
						"lg:grid-cols-3",
					);
					animeListContainer.classList.remove("flex", "flex-col");
					const rightSidebar = document.querySelector(
						".right-sidebar-container",
					);
					if (rightSidebar) rightSidebar.style.display = "none";
					const mainGrid = document.getElementById("main-grid");
					if (mainGrid) {
						mainGrid.style.gridTemplateColumns = "17.5rem 1fr";
						mainGrid.classList.add("two-column-layout");
					}
				} else {
					animeListContainer.classList.add(
						"list-mode",
						"flex",
						"flex-col",
					);
					animeListContainer.classList.remove(
						"grid",
						"grid-cols-1",
						"md:grid-cols-2",
						"lg:grid-cols-3",
					);
					const rightSidebar = document.querySelector(
						".right-sidebar-container",
					);
					if (rightSidebar) rightSidebar.style.display = "";
					const mainGrid = document.getElementById("main-grid");
					if (mainGrid) {
						mainGrid.style.gridTemplateColumns = "";
						mainGrid.classList.remove("two-column-layout");
					}
				}

				void animeListContainer.offsetHeight;

				requestAnimationFrame(() => {
					if (style.parentNode) style.parentNode.removeChild(style);

					animeItems.forEach((item) => {
						const first = firstPositions.get(item);
						if (!first) return;

						const last = item.getBoundingClientRect();

						const deltaX = first.left - last.left;
						const deltaY = first.top - last.top;
						const deltaW = first.width / last.width;
						const deltaH = first.height / last.height;

						if (
							Math.abs(deltaX) < 1 &&
							Math.abs(deltaY) < 1 &&
							Math.abs(deltaW - 1) < 0.01 &&
							Math.abs(deltaH - 1) < 0.01
						) {
							return;
						}

						item.style.transition = "none";
						item.style.transformOrigin = "top left";
						item.style.transform = `translate(${deltaX}px, ${deltaY}px) scale(${deltaW}, ${deltaH})`;
					});

					void animeListContainer.offsetHeight;

					requestAnimationFrame(() => {
						animeItems.forEach((item) => {
							if (!firstPositions.has(item)) return;
							item.style.transition =
								"transform 0.5s cubic-bezier(0.25, 0.8, 0.25, 1)";
							item.style.transform = "";
						});

						setTimeout(() => {
							animeItems.forEach((item) => {
								item.style.transition = "";
								item.style.transformOrigin = "";
								item.style.transform = "";
							});
						}, 500);
					});
				});
			}

			window.addEventListener("layoutChange", (event) => {
				updateAnimeListLayout(event.detail.layout);
			});

			const sentinel = document.getElementById(
				"infinite-scroll-sentinel",
			);
			const PAGE_SIZE = 24;

			if (sentinel) {
				const observer = new IntersectionObserver(
					(entries) => {
						entries.forEach((entry) => {
							if (entry.isIntersecting) {
								loadMoreItems();
							}
						});
					},
					{ rootMargin: "200px" },
				);

				observer.observe(sentinel);

				function loadMoreItems() {
					const hiddenItems =
						document.querySelectorAll(".initial-hidden");
					if (hiddenItems.length === 0) {
						sentinel.style.display = "none";
						observer.disconnect();
						return;
					}
					setTimeout(() => {
						for (
							let i = 0;
							i < PAGE_SIZE && i < hiddenItems.length;
							i++
						) {
							const item = hiddenItems[i];
							item.classList.remove("hidden", "initial-hidden");
							item.classList.add("anime-fade-in-active");
						}
						if (
							document.querySelectorAll(".initial-hidden")
								.length === 0
						) {
							sentinel.style.display = "none";
							observer.disconnect();
						}
					}, 300);
				}
			}

			const filterTags = document.querySelectorAll(".filter-tag");
			filterTags.forEach((tag) => {
				tag.addEventListener("click", function () {
					if (this.classList.contains("active")) return;
					filterTags.forEach((t) => t.classList.remove("active"));
					this.classList.add("active");

					if (sentinel) sentinel.style.display = "none";
					document
						.querySelectorAll(".initial-hidden")
						.forEach((el) => {
							el.classList.remove("hidden", "initial-hidden");
						});

					const status = this.getAttribute("data-status");
					const animeItems = document.querySelectorAll(
						"[data-anime-status]",
					);

					animeItems.forEach((item) => {
						const itemStatus =
							item.getAttribute("data-anime-status");
						const shouldShow =
							status === "all" || itemStatus === status;

						if (shouldShow) {
							item.classList.remove("hidden", "anime-hidden");
							item.classList.add("anime-fade-in-active");
							item.style.display = "";
						} else {
							item.classList.add("hidden", "anime-hidden");
							item.classList.remove("anime-fade-in-active");
						}
					});
				});
			});
		})();
	</script>

	<style>
		.card-base {
			container-type: inline-size;
		}
		.anime-grid-container {
			display: grid;
			grid-template-columns: repeat(2, 1fr);
			transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
		}
		.anime-grid-container.single-sidebar {
			@container (min-width: 900px) {
				grid-template-columns: repeat(5, 1fr);
			}
			@container (min-width: 600px) and (max-width: 899px) {
				grid-template-columns: repeat(3, 1fr);
			}
			@container (max-width: 599px) {
				grid-template-columns: repeat(2, 1fr);
			}
		}
		.anime-grid-container.both-sidebar {
			@container (min-width: 950px) {
				grid-template-columns: repeat(5, 1fr);
			}
			@container (min-width: 650px) and (max-width: 949px) {
				grid-template-columns: repeat(4, 1fr);
			}
			@container (min-width: 480px) and (max-width: 649px) {
				grid-template-columns: repeat(3, 1fr);
			}
			@container (max-width: 479px) {
				grid-template-columns: repeat(2, 1fr);
			}
		}

		[data-anime-status] {
			content-visibility: auto;
			contain-intrinsic-size: 1px 350px;
			transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
			backface-visibility: hidden;
			transform: translateZ(0);
			-webkit-font-smoothing: subpixel-antialiased;
			will-change: transform;
		}

		.filter-container {
			display: flex;
			flex-wrap: wrap;
			gap: 0.5rem;
		}
		.filter-tag {
			padding: 0.5rem 1rem;
			border: 1px solid var(--line-divider);
			border-radius: var(--radius-large);
			background: var(--btn-regular-bg);
			color: var(--btn-content);
			font-size: 0.875rem;
			font-weight: 500;
			cursor: pointer;
			transition: all 0.2s ease;
			white-space: nowrap;
		}
		.filter-tag:hover:not(.active) {
			background: var(--btn-hover-bg);
			border-color: var(--primary);
			transform: translateY(-1px);
		}
		.filter-tag.active {
			background: var(--primary);
			color: white;
			border-color: var(--primary);
		}

		.anime-fade-in-active {
			animation: fadeIn 0.5s ease-out forwards;
		}
		@keyframes fadeIn {
			from {
				opacity: 0;
				transform: translateY(10px);
			}
			to {
				opacity: 1;
				transform: translateY(0);
			}
		}

		.loading-spinner {
			border-right-color: var(--primary);
			animation: spin 1s linear infinite;
		}
		@keyframes spin {
			from {
				transform: rotate(0deg);
			}
			to {
				transform: rotate(360deg);
			}
		}
	</style>
</MainGridLayout>
